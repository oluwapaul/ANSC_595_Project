setwd('D:/Purdue/ANSC 595/Project/output/')

library(tidyverse)
library(qiime2R)
library(ggpubr)

meta<-read_q2metadata("project_metadata.txt")


# Alpha diversity
evenness = read_qza("evenness_vector.qza")
evenness<-evenness$data %>% rownames_to_column("SampleID") # this moves the sample names to a new column that matches the metadata and allows them to be merged

observed_features = read_qza("observed_features_vector.qza")
observed_features<-observed_features$data %>% rownames_to_column("SampleID") # this moves the sample names to a new column that matches the metadata and allows them to be merged

shannon = read_qza("shannon_vector.qza")
shannon<-shannon$data %>% rownames_to_column("SampleID") # this moves the sample names to a new column that matches the metadata and allows them to be merged

faith_pd = read_qza("faith_pd_vector.qza")
faith_pd<-faith_pd$data %>% rownames_to_column("SampleID") # this moves the sample names to a new column that matches the metadata and allows them to be merged\

## Clean up the data
# You can look at your data by clicking on it in the upper-right (Environment) 

# You always need to check the data types in your tables to make 
# sure they are what you want. We will now change some data types 
# in the meta now

#check the structure of the data
str(meta)
#check the levels of your factor
levels(meta$mode_delivery)
#observed_features$observed_features_num <- lapply(observed_features$observed_features, as.numeric)
#observed_features$observed_features <- as.numeric(observed_features$observed_features)
str(observed_features)


###Alpha Diversity tables
# These tables will be merged for convenience and added to the 
# metadata table as the original tutorial was organized.

alpha_diversity = merge(x=faith_pd, y=evenness, by.x = "SampleID", by.y = "SampleID")
alpha_diversity = merge(alpha_diversity, observed_features, by.x = "SampleID", by.y = "SampleID")
alpha_diversity = merge(alpha_diversity, shannon, by.x = "SampleID", by.y = "SampleID")
meta = merge(meta, alpha_diversity, by.x = "SampleID", by.y = "SampleID")
row.names(meta) = meta$SampleID
meta = meta[,-1]
str(meta)


#Alpha-diversity
# Alpha-diversity is within sample diversity. It is how many 
# different species (OTUs) are in each sample (richness) and how 
# evenly they are distributed (evenness), which together are diversity. 
# Each sample has one value for each metric.

#sum(observed_features$observed_features)

##Explore alpha metrics
# Now we will start to look at our data. We will first start with 
# alpha-diversity and richness. 
#
# You want the data to be roughly normal so that you can run ANOVA 
# or t-tests. If it is not normally distributed, you will need to 
# consider if you should normalize the data or usenon-parametric 
# tests such as Kruskal-Wallis.

# Here, we see that none of the data are normally distributed, 
# with the exception of "Faith" and "Observed Features".


#Plots
# view the histogram to see if it is normal
hist(meta$shannon, main="Shannon diversity", xlab="", breaks=10)
hist(meta$faith_pd, main="Faith phylogenetic diversity", xlab="", breaks=10)
hist(meta$pielou_e, main="Evenness", xlab="", breaks=10)
hist(as.numeric(meta$observed_features), main="Observed Features", xlab="", breaks=10)

#Plots the qq-plot for residuals
#Also check the qq-plot to see if it is normal
ggqqplot(meta$shannon, title = "Shannon")
ggqqplot(meta$faith_pd, title = "Faith PD")
ggqqplot(meta$pielou_e, title = "Evenness")
ggqqplot(meta$observed_features, title = "Observed Features")
``


# To test for normalcy statistically, we can run the Shapiro-Wilk 
# test of normality.
# This is the final test for normality, if this confirms the normality, go ahead if anova, it it is not normal then run kruskal wallis
shapiro.test(meta$shannon)
shapiro.test(meta$pielou_e)
shapiro.test(meta$faith_pd)
shapiro.test(meta$observed_features)

# The null hypothesis of these tests is that âsample distribution 
# is normalâ. If the test is significant, the distribution is non-normal.

# We see that, as expected from the graphs, shannon and evenness 
# are normally distributed.


#Overall, for alpha-diversity:

# ANOVA, t-test, or general linear models with the normal distribution 
# are used when the data is roughly normal. Transforming the data to 
# achieve a normal distribution could also be completed.
#
# Kruskal-Wallis, Wilcoxon rank sum test, or general linear models 
# with another distribution are used when the data is not normal or if 
# the n is low, like less than 30.

# Our main variables of interest are

# This are my variable names, yours will be different based on the name you used
# mode_delivery: CS, VG
# sample_type: Infant, Mother

## All the variables i am using for alpha diversity are categorical variables
# Now that we know which tests can be used, let's run them. 

## Normally distributed metrics

# Since it's the closest to normalcy, we will use **Evenness** as an 
#example. First, we will test mode_delivery, which is a categorical variable 
# with 2 levels. Thus, we run ANOVA. If age were only two 
# levels, we could run a t-test

# Does mode_delivery impact the Evenness of the microbiota?

#Run the ANOVA and save it as an object

#Because my data were not normal, i used kruskal wallis for all alpha diversity metrics
#this is not needed, it was usded in the tutorial script he sent colnames(meta)[3]= "sample_type"
#aov.evenness.mode_delivery = aov(pielou_evenness ~  sample_type ,data=meta)

#Call for the summary of that ANOVA, which will include P-values
#summary(aov.evenness.mode_delivery)

#To do all the pairwise comparisons between groups and correct for multiple comparisons, we run Tukey's honest significance test of our ANOVA.

#TukeyHSD(aov.evenness.body_site)

# We clearly see that the evenness between hands and gut are different. 
# When we plot the data, we see that evenness decreases in the gut 
# compared to palms.

#levels(meta$mode_delivery)
#Re-order the groups in case it is not in your prefered order
meta$mode_delivery.ord = factor(meta$mode_delivery, c("CS", "VG", "CS-M", "VG-M"))
levels(meta$mode_delivery.ord)

meta$sample_type.ord = factor(meta$sample_type, c("Infant", "Mother"))
levels(meta$sample_type.ord)


## **Non-normally distributed metrics**

# We will use **Faith's phylogenetic diversity** here. Since body site 
# is categorical, we use Kruskal-Wallis (non-parametric equivalent of 
# ANOVA). If we have only two levels, we would run Wilcoxon rank sum 
# test (non-parametric equivalent of t-test)

kruskal.test(pielou_evenness ~ mode_delivery, data=meta)
kruskal.test(faith_pd ~ mode_delivery, data=meta)
kruskal.test(observed_features ~ mode_delivery, data=meta)
kruskal.test(shannon_entropy ~ mode_delivery, data=meta)

kruskal.test(pielou_evenness ~ sample_type, data=meta)
kruskal.test(faith_pd ~ sample_type, data=meta)
kruskal.test(observed_features ~ sample_type, data=meta)
kruskal.test(shannon_entropy ~ sample_type, data=meta)

#This is not needed because we only have two groups under mode_delivery, only seperate means when you have more than two groups
#pairwise.wilcox.test(meta$pielou_evenness, meta$mode_delivery, p.adjust.method="BH")

#make boxplot
#x=mode_delivery and y=pielou_eveness
boxplot(pielou_evenness ~ mode_delivery.ord, data=meta, ylab="Peilou evenness", xlab="Mode of delivery")

#run eveness alone to see the colour change
evenness <- ggplot(meta, aes(mode_delivery, pielou_evenness)) + 
  geom_boxplot(aes(color = mode_delivery)) + 
  ylim(c(0.5,1)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))+
  scale_fill_discrete(name = "Delivery Mode")+
  labs(y="Evenness Diversity", x = "Mode of Delivery")
#ggsave("Image/evenness.png", evenness, height = 3, width = 6)


#x=mode_delivery and y=pielou_eveness
boxplot(faith_pd ~ mode_delivery.ord, data=meta, ylab="Faith Diversity", xlab="Mode of delivery")    
  
faith <- ggplot(meta, aes(mode_delivery, faith_pd)) + 
    geom_boxplot(aes(color = mode_delivery)) + 
    ylim(c(0.5,20)) +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))+
  labs(y="Faith Diversity", x = "Mode of Delivery")
  #ggsave("output/faith.png", faith, height = 3, width = 3)
  
#x=mode_delivery and y=observed OTU
boxplot(observed_features ~ mode_delivery.ord, data=meta, ylab="Obseerved OTU", xlab="Mode of delivery")
  
OTU <- ggplot(meta, aes(mode_delivery, observed_features)) + 
    geom_boxplot(aes(color = mode_delivery)) + 
    ylim(c(0.5,250)) +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))+
  labs(y="Observed OTU", x = "Mode of Delivery")
  #ggsave("output/otu.png", OTU, height = 3, width = 3)
  
#x=sample_type and y=pielou_eveness
boxplot(pielou_evenness ~ sample_type.ord, data=meta, ylab="Peilou evenness", xlab="Sample Type")
  
evenness2 <- ggplot(meta, aes(sample_type, pielou_evenness)) + 
    geom_boxplot(aes(color = sample_type)) + 
    ylim(c(0.5,1)) +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))+
  labs(y="Evenness Diversity", x = "Sample Type")
  #ggsave("output/evenness2.png", evenness, height = 3, width = 3)
  
  #x=sample_type and y=faith_pd
  boxplot(faith_pd ~ sample_type.ord, data=meta, ylab="Faith PD", xlab="Sample Type")
  
  faith2 <- ggplot(meta, aes(sample_type, faith_pd)) + 
    geom_boxplot(aes(color = sample_type)) + 
    ylim(c(0.5,20)) +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))+
  labs(y="Faith Diversity", x = "Sample Type")
  #ggsave("output/faith2.png", evenness, height = 3, width = 3)
  
  #x=sample_type and y=observed_features
  boxplot(observed_features ~ sample_type.ord, data=meta, ylab="OTU", xlab="Sample Type")
  OTU2 <- ggplot(meta, aes(sample_type.ord, observed_features)) + 
    geom_boxplot(aes(color = sample_type.ord)) + 
    ylim(c(0.5,250)) +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))+
  labs(y="Observed OTU", x = "Sample Type")
  #ggsave("output/otu2.png", evenness, height = 3, width = 3)
  
# ANOVA and Tukey are tests based on the mean, bar plot is preferable because boxplot plots the median. Its not wrong, its just not the best method. Unfortunately plotting the average and standard deviation is a little complicated.

#I am not usinf this because i am not usinf ANOVA test
#evenness_summary <- meta %>% # the names of the new data frame and the data frame to be summarised
  # group_by(body.site.ord) %>%   # the grouping variable
  # summarise(mean_evenness = mean(pielou_evenness),  # calculates the mean of each group
    #        sd_evenness = sd(pielou_evenness), # calculates the standard deviation of each group
     #       n_evenness = n(),  # calculates the sample size per group
      #      se_evenness = sd(pielou_evenness)/sqrt(n())) # calculates the standard error of each group

# We can now make a bar plot of means vs body site, with standard 
# deviations or standard errors as the error bar. The following code 
# uses the standard deviations.

# evenness_se <- ggplot(evenness_summary, aes(body.site.ord, mean_evenness, fill = body.site.ord)) + 
  # geom_col() + 
  # geom_errorbar(aes(ymin = mean_evenness - se_evenness, ymax = mean_evenness + se_evenness), width=0.2) + 
  # theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +
  # theme(legend.title = element_blank()) +
  # labs(y="Pielou's evenness  Â± s.e.", x = "") 

# ggsave("output/evenness_se.png", evenness_se, height = 3, width = 3)

#Beta Diversity
  
  metadata<-read_q2metadata("project_metadata.txt")
  metadata2 <- read.delim("project_metadata.txt", sep = "\t", header = T, quote = "", stringsAsFactors = F)
  metadata2 <- metadata2[-1,]
  str(metadata)
  levels(metadata$`mode_delivery`)
  
  row.names(metadata) <- metadata[ ,1]
 # metadata <- metadata[,-1]
  row.names(metadata)
  
  bc_PCoA<-read_qza("bray_curtis_pcoa_results.qza")
  
  body_colors <- c("Red", "Blue", "Green", "Yellow")
  
  bc_meta <- bc_PCoA$data$Vectors %>%
    select(SampleID, PC1, PC2) %>%
    inner_join(metadata, by = c("SampleID" = "SampleID"))
  
  my_column <- "mode_delivery"
  
  ggplot(bc_meta, aes(x=PC1, y=PC2, color=get(my_column))) +
    geom_point() + #alpha controls transparency and helps when points are overlapping
    theme_q2r() +
    xlab(paste0("PC1 (", round(100*bc_PCoA$data$ProportionExplained[1], digits = 2), "%)")) +
    ylab(paste0("PC2 (", round(100*bc_PCoA$data$ProportionExplained[2], digits = 2), "%)")) +
    scale_color_manual(values=body_colors, name = my_column)
  #ggsave(paste0("Image/BC-ellipse_basic_", my_column,".pdf"), height=3, width=4.5, device="pdf") # save a PDF 3 inches by 4 inches
  
  centroids <- aggregate(cbind(PC1,PC2)~get(my_column),bc_meta,mean)
  colnames(centroids)[1] <- "mode_delivery"
  
  ggplot(bc_meta, aes(x=PC1, y=PC2, color=get(my_column))) +
    geom_point() + #alpha controls transparency and helps when points are overlapping
    geom_point(data=centroids, size = 3) +
    theme_q2r() +
    stat_ellipse(level = 0.95, type = "t") +
    xlab(paste0("PC1 (", round(100*bc_PCoA$data$ProportionExplained[1], digits = 2), "%)")) +
    ylab(paste0("PC2 (", round(100*bc_PCoA$data$ProportionExplained[2], digits = 2), "%)")) +
    scale_color_manual(values=body_colors, name = my_column)
  #ggsave(paste0("Image/BC-ellipse_1", my_column,".pdf"), height=3, width=4.5, device="pdf") # save a PDF 3 inches by 4 inches
  
  ggplot(bc_meta, aes(x=PC1, y=PC2, color=get(my_column))) +
    geom_point(aes(shape= sample_type, color=get(my_column))) + #alpha controls transparency and helps when points are overlapping
    geom_point(data=centroids, size = 3) +
    theme_q2r() +
    stat_ellipse(level = 0.95, type = "t") +
    xlab(paste0("PC1 (", round(100*bc_PCoA$data$ProportionExplained[1], digits = 2), "%)")) +
    ylab(paste0("PC2 (", round(100*bc_PCoA$data$ProportionExplained[2], digits = 2), "%)")) 
  scale_color_manual(values=body_colors, name = my_column)
  #ggsave(paste0("Image/BC-ellipse_2", my_column,"-mode_delivery.pdf"), height=3, width=4.5, device="pdf") # save a PDF 3 inches by 4 inches
  
  
  #Jaccard
  jac_PCoA<-read_qza("jaccard_pcoa_results.qza")
  
  body_colors <- c("Red", "Blue")
  
  jac_meta <- jac_PCoA$data$Vectors %>%
    select(SampleID, PC1, PC2) %>%
    inner_join(metadata, by = c("SampleID" = "SampleID"))
  
  my_column <- "mode_delivery"
  
  ggplot(jac_meta, aes(x=PC1, y=PC2, color=get(my_column))) +
    geom_point() + #alpha controls transparency and helps when points are overlapping
    theme_q2r() +
    xlab(paste0("PC1 (", round(100*jac_PCoA$data$ProportionExplained[1], digits = 2), "%)")) +
    ylab(paste0("PC2 (", round(100*jac_PCoA$data$ProportionExplained[2], digits = 2), "%)")) +
    scale_color_manual(values=body_colors, name = my_column)
  #ggsave(paste0("Image/BC-ellipse_basic_", my_column,".pdf"), height=3, width=4.5, device="pdf") # save a PDF 3 inches by 4 inches
  
  centroids <- aggregate(cbind(PC1,PC2)~get(my_column),jac_meta,mean)
  colnames(centroids)[1] <- "mode_delivery"
  
  ggplot(jac_meta, aes(x=PC1, y=PC2, color=get(my_column))) +
    geom_point() + #alpha controls transparency and helps when points are overlapping
    geom_point(data=centroids, size = 3) +
    theme_q2r() +
    stat_ellipse(level = 0.95, type = "t") +
    xlab(paste0("PC1 (", round(100*jac_PCoA$data$ProportionExplained[1], digits = 2), "%)")) +
    ylab(paste0("PC2 (", round(100*jac_PCoA$data$ProportionExplained[2], digits = 2), "%)")) +
    scale_color_manual(values=body_colors, name = my_column)
  #ggsave(paste0("Image/BC-ellipse_1", my_column,".pdf"), height=3, width=4.5, device="pdf") # save a PDF 3 inches by 4 inches
  
  ggplot(jac_meta, aes(x=PC1, y=PC2, color=get(my_column))) +
    geom_point(aes(shape= sample_type, color=get(my_column))) + #alpha controls transparency and helps when points are overlapping
    geom_point(data=centroids, size = 3) +
    theme_q2r() +
    stat_ellipse(level = 0.95, type = "t") +
    xlab(paste0("PC1 (", round(100*jac_PCoA$data$ProportionExplained[1], digits = 2), "%)")) +
    ylab(paste0("PC2 (", round(100*jac_PCoA$data$ProportionExplained[2], digits = 2), "%)")) 
  scale_color_manual(values=body_colors, name = my_column)
  #ggsave(paste0("Image/BC-ellipse_2", my_column,"-mode_delivery.pdf"), height=3, width=4.5, device="pdf") # save a PDF 3 inches by 4 inches
  
  
  #Unweighted UniFrac
  unw_PCoA<-read_qza("unweighted_unifrac_pcoa_results.qza")
  
  body_colors <- c("Red", "Blue", "Green", "Yellow")
  
  unw_meta <- unw_PCoA$data$Vectors %>%
    select(SampleID, PC1, PC2) %>%
    inner_join(metadata, by = c("SampleID" = "SampleID"))
  
  my_column <- "mode_delivery"
  
  ggplot(unw_meta, aes(x=PC1, y=PC2, color=get(my_column))) +
    geom_point() + #alpha controls transparency and helps when points are overlapping
    theme_q2r() +
    xlab(paste0("PC1 (", round(100*unw_PCoA$data$ProportionExplained[1], digits = 2), "%)")) +
    ylab(paste0("PC2 (", round(100*unw_PCoA$data$ProportionExplained[2], digits = 2), "%)")) +
    scale_color_manual(values=body_colors, name = my_column)
  #ggsave(paste0("Image/BC-ellipse_basic_", my_column,".pdf"), height=3, width=4.5, device="pdf") # save a PDF 3 inches by 4 inches
  
  centroids <- aggregate(cbind(PC1,PC2)~get(my_column),unw_meta,mean)
  colnames(centroids)[1] <- "mode_delivery"
  
  ggplot(unw_meta, aes(x=PC1, y=PC2, color=get(my_column))) +
    geom_point() + #alpha controls transparency and helps when points are overlapping
    geom_point(data=centroids, size = 3) +
    theme_q2r() +
    stat_ellipse(level = 0.95, type = "t") +
    xlab(paste0("PC1 (", round(100*unw_PCoA$data$ProportionExplained[1], digits = 2), "%)")) +
    ylab(paste0("PC2 (", round(100*unw_PCoA$data$ProportionExplained[2], digits = 2), "%)")) +
    scale_color_manual(values=body_colors, name = my_column)
  #ggsave(paste0("Image/BC-ellipse_1", my_column,".pdf"), height=3, width=4.5, device="pdf") # save a PDF 3 inches by 4 inches
  
  ggplot(unw_meta, aes(x=PC1, y=PC2, color=get(my_column))) +
    geom_point(aes(shape= sample_type, color=get(my_column))) + #alpha controls transparency and helps when points are overlapping
    geom_point(data=centroids, size = 3) +
    theme_q2r() +
    stat_ellipse(level = 0.95, type = "t") +
    xlab(paste0("PC1 (", round(100*unw_PCoA$data$ProportionExplained[1], digits = 2), "%)")) +
    ylab(paste0("PC2 (", round(100*unw_PCoA$data$ProportionExplained[2], digits = 2), "%)")) 
  scale_color_manual(values=body_colors, name = my_column)
  #ggsave(paste0("Image/BC-ellipse_2", my_column,"-mode_delivery.pdf"), height=3, width=4.5, device="pdf") # save a PDF 3 inches by 4 inches
  
  
  #weighted UniFrac
  wu_PCoA<-read_qza("weighted_unifrac_pcoa_results.qza")
  
  body_colors <- c("Red", "Blue", "Green", "Yellow")
  
  wu_meta <- wu_PCoA$data$Vectors %>%
    select(SampleID, PC1, PC2) %>%
    inner_join(metadata, by = c("SampleID" = "SampleID"))
  
  my_column <- "mode_delivery"
  
  ggplot(wu_meta, aes(x=PC1, y=PC2, color=get(my_column))) +
    geom_point() + #alpha controls transparency and helps when points are overlapping
    theme_q2r() +
    xlab(paste0("PC1 (", round(100*wu_PCoA$data$ProportionExplained[1], digits = 2), "%)")) +
    ylab(paste0("PC2 (", round(100*wu_PCoA$data$ProportionExplained[2], digits = 2), "%)")) +
    scale_color_manual(values=body_colors, name = my_column)
  #ggsave(paste0("Image/BC-ellipse_basic_", my_column,".pdf"), height=3, width=4.5, device="pdf") # save a PDF 3 inches by 4 inches
  
  centroids <- aggregate(cbind(PC1,PC2)~get(my_column),wu_meta,mean)
  colnames(centroids)[1] <- "mode_delivery"
  
  ggplot(wu_meta, aes(x=PC1, y=PC2, color=get(my_column))) +
    geom_point() + #alpha controls transparency and helps when points are overlapping
    geom_point(data=centroids, size = 3) +
    theme_q2r() +
    stat_ellipse(level = 0.95, type = "t") +
    xlab(paste0("PC1 (", round(100*wu_PCoA$data$ProportionExplained[1], digits = 2), "%)")) +
    ylab(paste0("PC2 (", round(100*wu_PCoA$data$ProportionExplained[2], digits = 2), "%)")) +
    scale_color_manual(values=body_colors, name = my_column)
  #ggsave(paste0("Image/BC-ellipse_1", my_column,".pdf"), height=3, width=4.5, device="pdf") # save a PDF 3 inches by 4 inches
  
  ggplot(wu_meta, aes(x=PC1, y=PC2, color=get(my_column))) +
    geom_point(aes(shape= sample_type, color=get(my_column))) + #alpha controls transparency and helps when points are overlapping
    geom_point(data=centroids, size = 3) +
    theme_q2r() +
    stat_ellipse(level = 0.95, type = "t") +
    xlab(paste0("PC1 (", round(100*wu_PCoA$data$ProportionExplained[1], digits = 2), "%)")) +
    ylab(paste0("PC2 (", round(100*wu_PCoA$data$ProportionExplained[2], digits = 2), "%)")) 
  scale_color_manual(values=body_colors, name = my_column)
  #ggsave(paste0("Image/BC-ellipse_2", my_column,"-mode_delivery.pdf"), height=3, width=4.5, device="pdf") # save a PDF 3 inches by 4 inches
  
  #sample type
  
  bc_PCoA<-read_qza("bray_curtis_pcoa_results.qza")
  
  body_colors <- c("Red", "Blue")
  
  bc_meta <- bc_PCoA$data$Vectors %>%
    select(SampleID, PC1, PC2) %>%
    inner_join(metadata, by = c("SampleID" = "SampleID"))
  
  my_column <- "sample_type"
  
  ggplot(bc_meta, aes(x=PC1, y=PC2, color=get(my_column))) +
    geom_point() + #alpha controls transparency and helps when points are overlapping
    theme_q2r() +
    xlab(paste0("PC1 (", round(100*bc_PCoA$data$ProportionExplained[1], digits = 2), "%)")) +
    ylab(paste0("PC2 (", round(100*bc_PCoA$data$ProportionExplained[2], digits = 2), "%)")) +
    scale_color_manual(values=body_colors, name = my_column)
  #ggsave(paste0("Image/BC-ellipse_basic_", my_column,".pdf"), height=3, width=4.5, device="pdf") # save a PDF 3 inches by 4 inches
  
  centroids <- aggregate(cbind(PC1,PC2)~get(my_column),bc_meta,mean)
  colnames(centroids)[1] <- "sample_type"
  
  ggplot(bc_meta, aes(x=PC1, y=PC2, color=get(my_column))) +
    geom_point() + #alpha controls transparency and helps when points are overlapping
    geom_point(data=centroids, size = 3) +
    theme_q2r() +
    stat_ellipse(level = 0.95, type = "t") +
    xlab(paste0("PC1 (", round(100*bc_PCoA$data$ProportionExplained[1], digits = 2), "%)")) +
    ylab(paste0("PC2 (", round(100*bc_PCoA$data$ProportionExplained[2], digits = 2), "%)")) +
    scale_color_manual(values=body_colors, name = my_column)
  #ggsave(paste0("Image/BC-ellipse_1", my_column,".pdf"), height=3, width=4.5, device="pdf") # save a PDF 3 inches by 4 inches
  
  
  #Jaccard
  jac_PCoA<-read_qza("jaccard_pcoa_results.qza")
  
  body_colors <- c("Red", "Blue")
  
  jac_meta <- jac_PCoA$data$Vectors %>%
    select(SampleID, PC1, PC2) %>%
    inner_join(metadata, by = c("SampleID" = "SampleID"))
  
  my_column <- "sample_type"
  
  ggplot(jac_meta, aes(x=PC1, y=PC2, color=get(my_column))) +
    geom_point() + #alpha controls transparency and helps when points are overlapping
    theme_q2r() +
    xlab(paste0("PC1 (", round(100*jac_PCoA$data$ProportionExplained[1], digits = 2), "%)")) +
    ylab(paste0("PC2 (", round(100*jac_PCoA$data$ProportionExplained[2], digits = 2), "%)")) +
    scale_color_manual(values=body_colors, name = my_column)
  #ggsave(paste0("Image/BC-ellipse_basic_", my_column,".pdf"), height=3, width=4.5, device="pdf") # save a PDF 3 inches by 4 inches
  
  centroids <- aggregate(cbind(PC1,PC2)~get(my_column),jac_meta,mean)
  colnames(centroids)[1] <- "sample_type"
  
  ggplot(jac_meta, aes(x=PC1, y=PC2, color=get(my_column))) +
    geom_point() + #alpha controls transparency and helps when points are overlapping
    geom_point(data=centroids, size = 3) +
    theme_q2r() +
    stat_ellipse(level = 0.95, type = "t") +
    xlab(paste0("PC1 (", round(100*jac_PCoA$data$ProportionExplained[1], digits = 2), "%)")) +
    ylab(paste0("PC2 (", round(100*jac_PCoA$data$ProportionExplained[2], digits = 2), "%)")) +
    scale_color_manual(values=body_colors, name = my_column)
  #ggsave(paste0("Image/BC-ellipse_1", my_column,".pdf"), height=3, width=4.5, device="pdf") # save a PDF 3 inches by 4 inches

  
  #Unweighted UniFrac
  unw_PCoA<-read_qza("unweighted_unifrac_pcoa_results.qza")
  
  body_colors <- c("Red", "Blue")
  
  unw_meta <- unw_PCoA$data$Vectors %>%
    select(SampleID, PC1, PC2) %>%
    inner_join(metadata, by = c("SampleID" = "SampleID"))
  
  my_column <- "sample_type"
  
  ggplot(unw_meta, aes(x=PC1, y=PC2, color=get(my_column))) +
    geom_point() + #alpha controls transparency and helps when points are overlapping
    theme_q2r() +
    xlab(paste0("PC1 (", round(100*unw_PCoA$data$ProportionExplained[1], digits = 2), "%)")) +
    ylab(paste0("PC2 (", round(100*unw_PCoA$data$ProportionExplained[2], digits = 2), "%)")) +
    scale_color_manual(values=body_colors, name = my_column)
  #ggsave(paste0("Image/BC-ellipse_basic_", my_column,".pdf"), height=3, width=4.5, device="pdf") # save a PDF 3 inches by 4 inches
  
  centroids <- aggregate(cbind(PC1,PC2)~get(my_column),unw_meta,mean)
  colnames(centroids)[1] <- "sample_type"
  
  ggplot(unw_meta, aes(x=PC1, y=PC2, color=get(my_column))) +
    geom_point() + #alpha controls transparency and helps when points are overlapping
    geom_point(data=centroids, size = 3) +
    theme_q2r() +
    stat_ellipse(level = 0.95, type = "t") +
    xlab(paste0("PC1 (", round(100*unw_PCoA$data$ProportionExplained[1], digits = 2), "%)")) +
    ylab(paste0("PC2 (", round(100*unw_PCoA$data$ProportionExplained[2], digits = 2), "%)")) +
    scale_color_manual(values=body_colors, name = my_column)
  #ggsave(paste0("Image/BC-ellipse_1", my_column,".pdf"), height=3, width=4.5, device="pdf") # save a PDF 3 inches by 4 inches
  
  
  #weighted UniFrac sample_type
  wu_PCoA<-read_qza("weighted_unifrac_pcoa_results.qza")
  
  body_colors <- c("Red", "Blue")
  
  wu_meta <- wu_PCoA$data$Vectors %>%
    select(SampleID, PC1, PC2) %>%
    inner_join(metadata, by = c("SampleID" = "SampleID"))
  
  my_column <- "sample_type"
  
  ggplot(wu_meta, aes(x=PC1, y=PC2, color=get(my_column))) +
    geom_point() + #alpha controls transparency and helps when points are overlapping
    theme_q2r() +
    xlab(paste0("PC1 (", round(100*wu_PCoA$data$ProportionExplained[1], digits = 2), "%)")) +
    ylab(paste0("PC2 (", round(100*wu_PCoA$data$ProportionExplained[2], digits = 2), "%)")) +
    scale_color_manual(values=body_colors, name = my_column)
  #ggsave(paste0("Image/BC-ellipse_basic_", my_column,".pdf"), height=3, width=4.5, device="pdf") # save a PDF 3 inches by 4 inches
  
  centroids <- aggregate(cbind(PC1,PC2)~get(my_column),wu_meta,mean)
  colnames(centroids)[1] <- "sample_type"
  
  ggplot(wu_meta, aes(x=PC1, y=PC2, color=get(my_column))) +
    geom_point() + #alpha controls transparency and helps when points are overlapping
    geom_point(data=centroids, size = 3) +
    theme_q2r() +
    stat_ellipse(level = 0.95, type = "t") +
    xlab(paste0("PC1 (", round(100*wu_PCoA$data$ProportionExplained[1], digits = 2), "%)")) +
    ylab(paste0("PC2 (", round(100*wu_PCoA$data$ProportionExplained[2], digits = 2), "%)")) +
    scale_color_manual(values=body_colors, name = my_column)
  #ggsave(paste0("Image/BC-ellipse_1", my_column,".pdf"), height=3, width=4.5, device="pdf") # save a PDF 3 inches by 4 inches
  
  
  ##SAME thing but with weighted UniFrac
  
  Wuni_PCoA<-read_qza("weighted_unifrac_pcoa_results.qza")
  
  Wuni_meta <- Wuni_PCoA$data$Vectors %>%
    select(SampleID, PC1, PC2) %>%
    inner_join(metadata, by = c("SampleID" = "SampleID"))
  
  centroids <- aggregate(cbind(PC1,PC2)~get(my_column),Wuni_meta,mean)
  colnames(centroids)[1] <- "mode_delivery"
  
  ggplot(Wuni_meta, aes(x=PC1, y=PC2, color=get(my_column))) +
    geom_point() + #alpha controls transparency and helps when points are overlapping
    geom_point(data=centroids, size = 3) +
    theme_q2r() +
    stat_ellipse(level = 0.95, type = "t") +
    xlab(paste0("PC1 (", round(100*Wuni_PCoA$data$ProportionExplained[1], digits = 2), "%)")) +
    ylab(paste0("PC2 (", round(100*Wuni_PCoA$data$ProportionExplained[2], digits = 2), "%)")) +
    scale_color_manual(values=body_colors, name = "Body Site")
  #ggsave(paste0("Image/Wuni-ellipse_", my_column,".pdf"), height=3, width=4.5, device="pdf") # save a PDF 3 inches by 4 inches
  
  ggplot(Wuni_meta, aes(x=PC1, y=PC2, color=get(my_column))) +
    #geom_point(aes(shape= subject)) + #alpha controls transparency and helps when points are overlapping
    geom_point(data=centroids, size = 3) +
    theme_q2r() +
    stat_ellipse(level = 0.95, type = "t") +
    xlab(paste0("PC1 (", round(100*Wuni_PCoA$data$ProportionExplained[1], digits = 2), "%)")) +
    ylab(paste0("PC2 (", round(100*Wuni_PCoA$data$ProportionExplained[2], digits = 2), "%)")) +
    scale_color_manual(values=body_colors, name = "Body Site")
  #ggsave(paste0("Image/Wuni-ellipse_2", my_column,"-subject.pdf"), height=3, width=4.5, device="pdf") # save a PDF 3 inches by 4 inches
  
  
#Taxa Bar Plot
  
  library(phyloseq)
  #library(zoo)
  library(tidyverse)
  
  metadata<-read_q2metadata("project_metadata.txt")
  str(metadata)
  levels(metadata$mode_delivery)
  
  row.names(metadata) <- metadata[ ,1]
  metadata <- metadata[,-1]
  row.names(metadata)
  
  ##Qiime2r method of reading in the taxonomy files
  taxonomy<-read_qza("taxonomy.qza")
  head(taxonomy$data)
  
  tax.clean<-parse_taxonomy(taxonomy$data)
  head(tax.clean)
  
  #All this is OK except that in future use of the taxonomy table, 
  #these ASVs will be ignored because they are not classified. Why 
  #are ASVs not classified? Its because there is not a close enough 
  #match in the database. Just because there is not a good match in 
  #the database does not mean they donât exist, so I wanted to make 
  #sure this data was not lost. So in my new code, from lines 200 â 224 
  #I make it so that ASVs that are unclassified at any level are 
  #classified as the lowest taxonomic level for which there is a 
  #classification.
  #Next, all these `NA` classifications with the last level that was 
  #classified
  
  tax.clean[is.na(tax.clean)] <- ""
  for (i in 1:nrow(tax.clean)){
    if (tax.clean[i,2] == ""){
      kingdom <- paste("Kingdom_", tax.clean[i,1], sep = "")
      tax.clean[i, 2:7] <- kingdom
    } else if (tax.clean[i,3] == ""){
      phylum <- paste("Phylum_", tax.clean[i,2], sep = "")
      tax.clean[i, 3:7] <- phylum
    } else if (tax.clean[i,4] == ""){
      class <- paste("Class_", tax.clean[i,3], sep = "")
      tax.clean[i, 4:7] <- class
    } else if (tax.clean[i,5] == ""){
      order <- paste("Order_", tax.clean[i,4], sep = "")
      tax.clean[i, 5:7] <- order
    } else if (tax.clean[i,6] == ""){
      family <- paste("Family_", tax.clean[i,5], sep = "")
      tax.clean[i, 6:7] <- family
    } else if (tax.clean[i,7] == ""){
      tax.clean$Species[i] <- paste("Genus",tax.clean$Genus[i], sep = "_")
    }
  }
  
  
  
  #################################################################
  ##Taxa barplot
  #################################################################
  
  physeq <- qza_to_phyloseq(
    features="rarefied_table.qza",
    tree="rooted-tree.qza",
    "taxonomy.qza",
    metadata = "project_metadata.txt"
  )
  
  
  #First get the OTU table from physeq
  physeq_otu_table <- data.frame(otu_table(physeq), check.names = F)
  
  
  #filtering txonomy by row, if the the tax.clean and phyloseq_otu_table has the same colum should be checked
  tax.clean = tax.clean[row.names(tax.clean) %in% rownames(physeq_otu_table),]
  metadata.filtered = metadata[row.names(metadata) %in% colnames(physeq_otu_table),]
  
  #Assign as variables to be feed into phyloseq
  OTU.physeq = otu_table(as.matrix(physeq_otu_table), taxa_are_rows=TRUE)
  
  #our edited and formatted taxonomy table from the top of this script
  tax.physeq = tax_table(as.matrix(tax.clean))    
  meta.physeq = sample_data(metadata.filtered)
  
  #We then merge these into an object of class phyloseq.
  
  physeq_bar_plot = phyloseq(OTU.physeq, tax.physeq, meta.physeq)
  
  
  
  # Set colors for plotting, these colours were gotten from color brewer
  my_colors <- c(
    '#a6cee3','#1f78b4','#b2df8a','#33a02c','#fb9a99','#e31a1c',
    '#fdbf6f','#ff7f00','#cab2d6','#6a3d9a','#ffff99','#b15928', 
    "#CBD588", "#5F7FC7", "orange","#DA5724", "#508578", "#CD9BCD",
    "#AD6F3B", "#673770","#D14285", "#652926", "#C84248", 
    "#8569D5", "#5E738F","#D1A33D", "#8A7C64", "#599861", "gray", "black"
  )
  
  #If you want different taxonomic level, find and replace the taxonomic level listed here
  my_level <- c("Phylum", "Family", "Genus")
  my_column <- "mode_delivery"
  
  #This has not be created yet
  #rm(taxa.summary)
  
  #Each ASV must have an abundance of at least 2% and must shown at least of ASV
  abund_filter <- 0.02
  
  #asign ml as the level to be used in my_level
  #ml ="Genus", ml="Family", ml="Phylum"
  
  for(ml in my_level){
    print(ml)
    
    taxa.summary <- physeq_bar_plot %>%
      tax_glom(taxrank = ml, NArm = FALSE) %>%  # agglomerate at `ml` level
      transform_sample_counts(function(x) {x/sum(x)} ) %>% # Transform to rel. abundance
      psmelt()  %>%                               # Melt to long format
      group_by(get(my_column), get(ml)) %>%
      summarise(Abundance.average=mean(Abundance)) 
    taxa.summary <- as.data.frame(taxa.summary)
    colnames(taxa.summary)[1] <- my_column
    colnames(taxa.summary)[2] <- ml
    
    physeq.taxa.average <- taxa.summary %>% 
      group_by(get(ml)) %>%
      summarise(overall.max=max(Abundance.average))
    
    physeq.taxa.average <- as.data.frame(physeq.taxa.average)
    colnames(physeq.taxa.average)[1] <- ml
    
    # merging the phyla means with the metadata #
    physeq_meta <- merge(taxa.summary, physeq.taxa.average)
    
    
    physeq_meta_filtered <- filter(physeq_meta, overall.max>abund_filter)
    #str(physeq_meta_filtered)
    
    #physeq_meta_filtered$body.site.ord = factor(physeq_meta_filtered$body.site, c("left palm", "right palm", "gut", "tongue"))
    
    # Plot 
    ggplot(physeq_meta_filtered, aes(x = get(my_column), y = Abundance.average, fill = get(ml))) + 
      #facet_grid(.~LitterTreatment) +
      geom_bar(stat = "identity") +
      scale_fill_manual(values = my_colors) +
      # Remove x axis title
      #theme(axis.title.x = element_blank()) + 
      ylim(c(0,1)) +
      guides(fill = guide_legend(reverse = F, keywidth = .5, keyheight = .5, ncol = 1)) +
      theme(legend.text=element_text(size=8)) +
      #theme(legend.position="bottom") +
      theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +
      theme(legend.title = element_blank()) +
      ylab("Relative Abundance") +
      xlab(my_column) +
      ggtitle(paste0(ml, " (>", abund_filter * 100,"%) in at least 1 treatment group")) 
    ggsave(paste0("output/", ml, "BarPlot_", my_column, ".png"), height = 5)
  }
  
  
  #DESeq
  library("DESeq2")
  
  
  #To use DESeq, we need no zeros in our OTU table. So we will edit the table by multiplying by 2 and + 1
  
  #First get the OTU table from physeq
  physeq_otu_table <- data.frame(otu_table(physeq), check.names = FALSE)
  
  OTU.clean2 <- physeq_otu_table + 1
  
  
  #Now make the phyloseq object:
  
  
  OTU.physeq = otu_table(as.matrix(OTU.clean2), taxa_are_rows=TRUE)
  tax.physeq = tax_table(as.matrix(tax.clean))
  meta.physeq = sample_data(metadata.filtered)
  
  
  #We then merge these into an object of class phyloseq.
  
  
  physeq_deseq = phyloseq(OTU.physeq, tax.physeq, meta.physeq)
  
  
  #The following two lines actually do all the complicated DESeq2 work. The function phyloseq_to_deseq2 converts your phyloseq-format microbiome data into a DESeqDataSet with dispersions estimated, using the experimental design formula, also shown (the ~body.site term). The DESeq function does the rest of the testing, in this case with default testing framework, but you can actually use alternatives.
  
  
  diagdds = phyloseq_to_deseq2(physeq_deseq, ~ sample_type)
  diagdds = DESeq(diagdds, test="Wald", fitType="parametric")
  #the test type of "Wald" tests for significance of coefficients in a Negative Binomial GLM. This is generally a pretty good assumption for sequencing experiments. This was designed with RNA-seq in mind, but also pretty good for 16S sequencing.
  
  
  ###Investigate test results table
  
  #The following results function call creates a table of the results of the tests. Very fast. The hard work was already stored with the rest of the DESeq2-related data in our latest version of the diagdds object (see above). I then order by the adjusted p-value, removing the entries with an NA value. The rest of this example is just formatting the results table with taxonomic information for nice(ish) display in the HTML output.
  
  #Contrast: this argument specifies what comparison to extract from the object to build a results table. There are exactly three elements:
  
  #  1. the name of a factor in the design formula, 
  #  2. the name of the numerator level for the fold change, and 
  #  3. the name of the denominator level for the fold change (simplest case)
  
  alpha = 0.01
  my_contrast = c("sample_type", "Infant", "Mother") 
  #my_contrast = c("mode_delivery", "CS", "CS-M", "VG", "VG-M") 
  #my_contrast = c("bodysite", "gut", "tongue") 
  #my_contrast = c("bodysite", "tongue", "left palm") 
  #my_contrast = c("bodysite", "tongue", "right palm") 
  #my_contrast = c("bodysite", "right palm", "left palm") 
  
  res = results(diagdds, contrast = my_contrast, cooksCutoff = FALSE)
  
  sigtab = res[which(res$padj < alpha), ]
  #sigtab_test <- as(sigtab, "data.frame")
  sigtab = cbind(as(sigtab, "data.frame"), as(tax_table(physeq_deseq)[rownames(sigtab), ], "matrix"))
  #head(sigtab)
  
  
  ###Volcano Plot
  
  with(res, plot(log2FoldChange, -log10(padj), pch=20, main="Volcano plot", xlim=c(-15,15)))
  
  # Add colored points: blue if padj<0.01, red if log2FC>1 and padj<0.05)
  with(subset(res, padj<.01 ), points(log2FoldChange, -log10(pvalue), pch=20, col="blue"))
  with(subset(res, padj<.01 & abs(log2FoldChange)>2), points(log2FoldChange, -log10(pvalue), pch=20, col="red"))
  
  
  #Let's look at the OTUs that were significantly different between the two treatment groups. The following makes a nice ggplot2 summary of the results.
  
  
  theme_set(theme_bw())
  scale_fill_discrete <- function(palname = "Set1", ...) {
    scale_fill_brewer(palette = palname, ...)
  }
  # Phylum order
  #x = tapply(sigtab$log2FoldChange, sigtab$Phylum, function(x) max(x))
  #x = sort(x, TRUE)
  #sigtab$Phylum = factor(as.character(sigtab$Phylum), levels=names(x))
  # Genus order
  x = tapply(sigtab$log2FoldChange, sigtab$Genus, function(x) max(x))
  x = sort(x, TRUE)
  sigtab$Genus = factor(as.character(sigtab$Genus), levels=names(x))
  DESeq_fig = ggplot(sigtab, aes(x=Genus, y = log2FoldChange, color=Phylum)) + 
    geom_point(size=3) + 
    ylab(paste0("(", my_contrast[2], "/", my_contrast[3], ")\n", "log2FoldChange")) +
    scale_color_manual(values = my_colors[c(4,6,8,10,12,14,16,18,20)]) +
    #ylim(0,8) +
    theme(axis.text.x = element_text(angle = -90, hjust = 0, vjust=0.5))
  
  ggsave(paste0("Image/DESeq2_sample_type-", my_contrast[2], "-", my_contrast[3], ".png"), DESeq_fig, height = 7, width = 14)